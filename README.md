# World Server (C#) - 오픈월드 액션 RPG형(세션/인스턴스) 구조

## 1) 프로젝트 한 줄 소개
멀티플레이 게임에서 **플레이어 이동 / 월드 전환 / 시야(뷰) 갱신 / 몬스터 상태 동기화**를 담당하는 **World Server** 모듈입니다.  
네트워크 패킷을 통해 클라이언트에 월드 상태를 효율적으로 전송하고, 셀(그리드) 기반으로 오브젝트 가시성을 관리합니다.
---

## 2) 핵심 기능 (What I Built)

### A. 이동 처리 & 셀 기반 가시성(View) 갱신
- 플레이어 이동 명령 처리 시,
    - 기존 위치의 셀(old cell)과 신규 위치의 셀(new cell)을 계산
    - 셀 변경이 발생하면 **Leave/Enter**로 셀 내 오브젝트 관리
    - 뷰 업데이트 대상 셀을 계산해 **스폰/디스폰(보이기/가리기)** 갱신을 전송

**포인트**
- “같은 셀 내 이동”은 빠르게 종료하여 불필요한 연산/패킷을 줄였습니다.
- 셀 단위로 뷰를 관리해 대규모 월드에서도 확장 가능하도록 구성했습니다.

---

### B. 뷰 업데이트 패킷 배치 전송(Batching) 최적화
- 셀들에 포함된 오브젝트들을 순회하며,
    - **중복 전송 방지(HashSet 기반 seen 체크)**
    - 일정 개수 단위로 묶어 **배치 전송**
- 오브젝트가 많아도 네트워크 부담을 줄이고, 패킷 폭주를 방지합니다.

**포인트**
- 배치 리스트를 유지하면서 최대치 도달 시 즉시 전송 → “메모리/대역폭 균형”
- 플레이어 자신은 전송 대상에서 제외하여 불필요한 데이터 전송을 줄였습니다.

---

### C. 월드 전환(Change World) 처리의 안정성
- 월드 전환 요청 시,
    - 데이터 테이블(WorldInfo) 유효성 검증
    - 월드 맵 초기화 및 스폰 지점 셀 검증
    - 전환 결과 응답 패킷 전송
- **동시 월드 전환 방지**를 위해 원자적 플래그(Interlocked)를 사용했습니다.

**포인트**
- “중복 요청/레이스 컨디션”을 막아 월드 상태가 꼬이는 문제를 예방
- 스폰 셀 미존재 등 예외 케이스를 명확히 처리하여 운영 안정성을 확보

---

### D. 몬스터 변경사항(Dirty) 기반 동기화
- 몬스터 목록 중 변경된 대상만 추려서(Dirty Check) 처리
- 위치가 바뀐 경우:
    - 셀 이동(Leave/Enter) 반영
    - 관련 MonsterGroup 상태(전투 여부 등) 업데이트
- 클라이언트 전송은 최대 개수 단위로 끊어서 배치 전송합니다.

**포인트**
- “변경된 몬스터만 전송”하여 CPU/네트워크 비용 절감
- 그룹 단위 상태 업데이트로 AI/전투 로직과 자연스럽게 연동 가능

---

## 3) 기술 스택 & 키워드
- **Language**: C#
- **Architecture/Domain**: World Server, Cell(Grid) 기반 Spatial Partitioning, Object Visibility
- **Networking**: 소켓 기반 프로토콜 계층, 커맨드 패킷 송수신
- **Serialization**: MemoryPack 기반 직렬화(고성능 바이너리 직렬화 지향)
- **Concurrency**: Interlocked를 이용한 상태 플래그 제어
- **Optimization**: 중복 제거, 배치 전송, Dirty 업데이트

---

## 4) 내가 기여한 설계 의사결정 (Why It Matters)
1. **셀 기반 가시성 관리**
    - 월드가 커질수록 “거리 기반/셀 기반”으로 가시성 범위를 제한해야 서버 비용이 선형적으로 폭증하지 않음
2. **배치 전송 + 중복 제거**
    - 오브젝트가 여러 셀 계산 결과에 포함될 수 있으므로, 중복 전송을 막아 트래픽을 안정화
3. **Dirty Update**
    - 프레임마다 전체를 보내는 방식 대신 변경분만 전송해 확장성과 비용 효율을 확보
4. **월드 전환의 원자성 확보**
    - 실서비스에서 가장 흔한 장애 포인트인 “중복 요청/순서 꼬임”을 방어

---

## 5) 개선 아이디어 (Next Steps)
- **AOI(Area of Interest) 고도화**: 셀 기반 + 거리 기반 혼합, 우선순위 큐로 중요 오브젝트 우선 전송
- **패킷 스케줄링**: Spawn/Despawn/Update를 틱 단위로 조절해 급격한 이동 시 트래픽 스파이크 완화
- **오브젝트 풀링**: 배치 리스트/패킷 객체 풀링으로 GC 압력 감소
- **관측성(Observability)**: 셀별 오브젝트 수, 패킷 크기/빈도, 처리 시간 등을 지표화하여 병목 추적

---

## 6) 핵심 요약
- **이동 → 셀 전환 → 가시성 업데이트** 파이프라인을 구성하고,
- **배치 전송/중복 제거/Dirty 업데이트**로 성능과 트래픽을 최적화